using Design.ORiN3.Provider.V1.Type;
using Message.ORiN3.Common.V1;
using Message.ORiN3.Common.V1.AutoGenerated;
using Message.ORiN3.Common.V1.Factory;
using System;
using System.Collections.Generic;
using System.Linq;
using Xunit;

namespace Message.ORiN3.Common.Test.TestByDeveloper
{
    public class ORiN3ValueFactoryTest
    {
        private static void MakeSureNull(ORiN3ValueType notNull, ORiN3Value actual)
        {
            if (notNull != ORiN3ValueType.ORiN3Bool) Assert.Null(actual.Bool);
            if (notNull != ORiN3ValueType.ORiN3BoolArray) Assert.Null(actual.BoolArray);
            if (notNull != ORiN3ValueType.ORiN3NullableBool) Assert.Null(actual.NullableBool);
            if (notNull != ORiN3ValueType.ORiN3NullableBoolArray) Assert.Null(actual.NullableBoolArray);
            if (notNull != ORiN3ValueType.ORiN3UInt8) Assert.Null(actual.UInt8);
            if (notNull != ORiN3ValueType.ORiN3UInt8Array) Assert.Null(actual.UInt8Array);
            if (notNull != ORiN3ValueType.ORiN3NullableUInt8) Assert.Null(actual.NullableUInt8);
            if (notNull != ORiN3ValueType.ORiN3NullableUInt8Array) Assert.Null(actual.NullableUInt8Array);
            if (notNull != ORiN3ValueType.ORiN3UInt16) Assert.Null(actual.UInt16);
            if (notNull != ORiN3ValueType.ORiN3UInt16Array) Assert.Null(actual.UInt16Array);
            if (notNull != ORiN3ValueType.ORiN3NullableUInt16) Assert.Null(actual.NullableUInt16);
            if (notNull != ORiN3ValueType.ORiN3NullableUInt16Array) Assert.Null(actual.NullableUInt16Array);
            if (notNull != ORiN3ValueType.ORiN3UInt32) Assert.Null(actual.UInt32);
            if (notNull != ORiN3ValueType.ORiN3UInt32Array) Assert.Null(actual.UInt32Array);
            if (notNull != ORiN3ValueType.ORiN3NullableUInt32) Assert.Null(actual.NullableUInt32);
            if (notNull != ORiN3ValueType.ORiN3NullableUInt32Array) Assert.Null(actual.NullableUInt32Array);
            if (notNull != ORiN3ValueType.ORiN3UInt64) Assert.Null(actual.UInt64);
            if (notNull != ORiN3ValueType.ORiN3UInt64Array) Assert.Null(actual.UInt64Array);
            if (notNull != ORiN3ValueType.ORiN3NullableUInt64) Assert.Null(actual.NullableUInt64);
            if (notNull != ORiN3ValueType.ORiN3NullableUInt64Array) Assert.Null(actual.NullableUInt64Array);
            if (notNull != ORiN3ValueType.ORiN3Int8) Assert.Null(actual.Int8);
            if (notNull != ORiN3ValueType.ORiN3Int8Array) Assert.Null(actual.Int8Array);
            if (notNull != ORiN3ValueType.ORiN3NullableInt8) Assert.Null(actual.NullableInt8);
            if (notNull != ORiN3ValueType.ORiN3NullableInt8Array) Assert.Null(actual.NullableInt8Array);
            if (notNull != ORiN3ValueType.ORiN3Int16) Assert.Null(actual.Int16);
            if (notNull != ORiN3ValueType.ORiN3Int16Array) Assert.Null(actual.Int16Array);
            if (notNull != ORiN3ValueType.ORiN3NullableInt16) Assert.Null(actual.NullableInt16);
            if (notNull != ORiN3ValueType.ORiN3NullableInt16Array) Assert.Null(actual.NullableInt16Array);
            if (notNull != ORiN3ValueType.ORiN3Int32) Assert.Null(actual.Int32);
            if (notNull != ORiN3ValueType.ORiN3Int32Array) Assert.Null(actual.Int32Array);
            if (notNull != ORiN3ValueType.ORiN3NullableInt32) Assert.Null(actual.NullableInt32);
            if (notNull != ORiN3ValueType.ORiN3NullableInt32Array) Assert.Null(actual.NullableInt32Array);
            if (notNull != ORiN3ValueType.ORiN3Int64) Assert.Null(actual.Int64);
            if (notNull != ORiN3ValueType.ORiN3Int64Array) Assert.Null(actual.Int64Array);
            if (notNull != ORiN3ValueType.ORiN3NullableInt64) Assert.Null(actual.NullableInt64);
            if (notNull != ORiN3ValueType.ORiN3NullableInt64Array) Assert.Null(actual.NullableInt64Array);
            if (notNull != ORiN3ValueType.ORiN3Float) Assert.Null(actual.Float);
            if (notNull != ORiN3ValueType.ORiN3FloatArray) Assert.Null(actual.FloatArray);
            if (notNull != ORiN3ValueType.ORiN3NullableFloat) Assert.Null(actual.NullableFloat);
            if (notNull != ORiN3ValueType.ORiN3NullableFloatArray) Assert.Null(actual.NullableFloatArray);
            if (notNull != ORiN3ValueType.ORiN3Double) Assert.Null(actual.Double);
            if (notNull != ORiN3ValueType.ORiN3DoubleArray) Assert.Null(actual.DoubleArray);
            if (notNull != ORiN3ValueType.ORiN3NullableDouble) Assert.Null(actual.NullableDouble);
            if (notNull != ORiN3ValueType.ORiN3NullableDoubleArray) Assert.Null(actual.NullableDoubleArray);
            if (notNull != ORiN3ValueType.ORiN3DateTime) Assert.Null(actual.DateTime);
            if (notNull != ORiN3ValueType.ORiN3DateTimeArray) Assert.Null(actual.DateTimeArray);
            if (notNull != ORiN3ValueType.ORiN3NullableDateTime) Assert.Null(actual.NullableDateTime);
            if (notNull != ORiN3ValueType.ORiN3NullableDateTimeArray) Assert.Null(actual.NullableDateTimeArray);
            if (notNull != ORiN3ValueType.ORiN3String) Assert.Null(actual.String);
            if (notNull != ORiN3ValueType.ORiN3StringArray) Assert.Null(actual.StringArray);
            if (notNull != ORiN3ValueType.ORiN3Object) Assert.Null(actual.Object);
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "bool")]
        [InlineData(true)]
        [InlineData(false)]
        public void BoolTest(bool data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3Bool, actual.Type);
            Assert.Equal(data, actual.Bool.RawValue);
            MakeSureNull(ORiN3ValueType.ORiN3Bool, actual);
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "bool[]")]
        [InlineData(new bool[0])]
        [InlineData(new[] { true })]
        [InlineData(new[] { false })]
        [InlineData(new[] { true, false, true })]
        public void BoolArrayTest(bool[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3BoolArray, actual.Type);
            Assert.Equal(data, actual.BoolArray.RawValue);
            MakeSureNull(ORiN3ValueType.ORiN3BoolArray, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "bool[]")]
        public void BoolArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((bool[])null);
            });
        }

        [Theory]
        [InlineData(null)]
        [InlineData(true)]
        [InlineData(false)]
        [Trait(nameof(ORiN3ValueFactory), "bool?")]
        public void NullableBoolTest(bool? data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableBool, actual.Type);
            Assert.Equal(data.HasValue, !actual.NullableBool.IsNull);
            if (data.HasValue)
            {
                Assert.Equal(data.Value, actual.NullableBool.RawValue);
            }
            else
            {
                Assert.Equal(default, actual.NullableBool.RawValue);
            }
            MakeSureNull(ORiN3ValueType.ORiN3NullableBool, actual);
        }

        public static IEnumerable<object[]> NullableBoolArrayTestData
        {
            get
            {
                yield return new object[] { Array.Empty<bool?>() };
                yield return new object[] { new bool?[] { true } };
                yield return new object[] { new bool?[] { false } };
                yield return new object[] { new bool?[] { null } };
                yield return new object[] { new bool?[] { true, false, null } };
            }
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "bool?[]")]
        [MemberData(nameof(NullableBoolArrayTestData))]
        public void NullableBoolArrayTest(bool?[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableBoolArray, actual.Type);
            Assert.Equal(data, actual.NullableBoolArray.RawValue.Select(_ => (bool?)(_.IsNull ? null : _.RawValue)));
            MakeSureNull(ORiN3ValueType.ORiN3NullableBoolArray, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "bool?[]")]
        public void NullableBoolArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((bool?[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "byte")]
        [InlineData(byte.MinValue)]
        [InlineData(byte.MaxValue)]
        public void UInt8Test(byte data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3UInt8, actual.Type);
            Assert.Equal(data, actual.UInt8.RawValue);
            MakeSureNull(ORiN3ValueType.ORiN3UInt8, actual);
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "byte[]")]
        [InlineData(new byte[0])]
        [InlineData(new[] { byte.MinValue })]
        [InlineData(new[] { byte.MaxValue })]
        [InlineData(new[] { byte.MinValue, byte.MaxValue, byte.MinValue })]
        public void UInt8ArrayTest(byte[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3UInt8Array, actual.Type);
            Assert.Equal(data, actual.UInt8Array.RawValue.Select(_ => (byte)_));
            MakeSureNull(ORiN3ValueType.ORiN3UInt8Array, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "byte[]")]
        public void UInt8ArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((byte[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "byte?")]
        [InlineData(null)]
        [InlineData(byte.MinValue)]
        [InlineData(byte.MaxValue)]
        public void NullableUInt8Test(byte? data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableUInt8, actual.Type);
            Assert.Equal(data.HasValue, !actual.NullableUInt8.IsNull);
            if (data.HasValue)
            {
                Assert.Equal(data.Value, actual.NullableUInt8.RawValue);
            }
            else
            {
                Assert.Equal(default, actual.NullableUInt8.RawValue);
            }
            MakeSureNull(ORiN3ValueType.ORiN3NullableUInt8, actual);
        }

        public static IEnumerable<object[]> NullableUInt8ArrayTestData
        {
            get
            {
                yield return new object[] { Array.Empty<byte?>() };
                yield return new object[] { new byte?[] { byte.MinValue } };
                yield return new object[] { new byte?[] { byte.MaxValue } };
                yield return new object[] { new byte?[] { null } };
                yield return new object[] { new byte?[] { byte.MinValue, byte.MaxValue, null } };
            }
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "byte?[]")]
        [MemberData(nameof(NullableUInt8ArrayTestData))]
        public void NullableUInt8ArrayTest(byte?[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableUInt8Array, actual.Type);
            Assert.Equal(data, actual.NullableUInt8Array.RawValue.Select(_ => _.IsNull ? null : (byte?)_.RawValue));
            MakeSureNull(ORiN3ValueType.ORiN3NullableUInt8Array, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "byte?[]")]
        public void NullableUInt8ArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((byte?[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "ushort")]
        [InlineData(ushort.MinValue)]
        [InlineData(ushort.MaxValue)]
        public void UInt16Test(ushort data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3UInt16, actual.Type);
            Assert.Equal(data, actual.UInt16.RawValue);
            MakeSureNull(ORiN3ValueType.ORiN3UInt16, actual);
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "ushort[]")]
        [InlineData(new ushort[0])]
        [InlineData(new[] { ushort.MinValue })]
        [InlineData(new[] { ushort.MaxValue })]
        [InlineData(new[] { ushort.MinValue, ushort.MaxValue, ushort.MinValue })]
        public void UInt16ArrayTest(ushort[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3UInt16Array, actual.Type);
            Assert.Equal(data, actual.UInt16Array.RawValue.Select(_ => (ushort)_));
            MakeSureNull(ORiN3ValueType.ORiN3UInt16Array, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "ushort[]")]
        public void UInt16ArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((ushort[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "ushort?")]
        [InlineData(null)]
        [InlineData(ushort.MinValue)]
        [InlineData(ushort.MaxValue)]
        public void NullableUInt16Test(ushort? data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableUInt16, actual.Type);
            Assert.Equal(data.HasValue, !actual.NullableUInt16.IsNull);
            if (data.HasValue)
            {
                Assert.Equal(data.Value, actual.NullableUInt16.RawValue);
            }
            else
            {
                Assert.Equal(default, actual.NullableUInt16.RawValue);
            }
            MakeSureNull(ORiN3ValueType.ORiN3NullableUInt16, actual);
        }

        public static IEnumerable<object[]> NullableUInt16ArrayTestData
        {
            get
            {
                yield return new object[] { Array.Empty<ushort?>() };
                yield return new object[] { new ushort?[] { ushort.MinValue } };
                yield return new object[] { new ushort?[] { ushort.MaxValue } };
                yield return new object[] { new ushort?[] { null } };
                yield return new object[] { new ushort?[] { ushort.MinValue, ushort.MaxValue, null } };
            }
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "ushort?[]")]
        [MemberData(nameof(NullableUInt16ArrayTestData))]
        public void NullableUInt16ArrayTest(ushort?[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableUInt16Array, actual.Type);
            Assert.Equal(data, actual.NullableUInt16Array.RawValue.Select(_ => _.IsNull ? null : (ushort?)_.RawValue));
            MakeSureNull(ORiN3ValueType.ORiN3NullableUInt16Array, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "ushort?[]")]
        public void NullableUInt16ArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((ushort?[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "uint")]
        [InlineData(uint.MinValue)]
        [InlineData(uint.MaxValue)]
        public void UInt32Test(uint data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3UInt32, actual.Type);
            Assert.Equal(data, actual.UInt32.RawValue);
            MakeSureNull(ORiN3ValueType.ORiN3UInt32, actual);
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "uint[]")]
        [InlineData(new uint[0])]
        [InlineData(new[] { uint.MinValue })]
        [InlineData(new[] { uint.MaxValue })]
        [InlineData(new[] { uint.MinValue, uint.MaxValue, uint.MinValue })]
        public void UInt32ArrayTest(uint[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3UInt32Array, actual.Type);
            Assert.Equal(data, actual.UInt32Array.RawValue);
            MakeSureNull(ORiN3ValueType.ORiN3UInt32Array, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "uint[]")]
        public void UInt32ArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((uint[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "uint?")]
        [InlineData(null)]
        [InlineData(uint.MinValue)]
        [InlineData(uint.MaxValue)]
        public void NullableUInt32Test(uint? data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableUInt32, actual.Type);
            Assert.Equal(data.HasValue, !actual.NullableUInt32.IsNull);
            if (data.HasValue)
            {
                Assert.Equal(data.Value, actual.NullableUInt32.RawValue);
            }
            else
            {
                Assert.Equal(default, actual.NullableUInt32.RawValue);
            }
            MakeSureNull(ORiN3ValueType.ORiN3NullableUInt32, actual);
        }

        public static IEnumerable<object[]> NullableUInt32ArrayTestData
        {
            get
            {
                yield return new object[] { Array.Empty<uint?>() };
                yield return new object[] { new uint?[] { uint.MinValue } };
                yield return new object[] { new uint?[] { uint.MaxValue } };
                yield return new object[] { new uint?[] { null } };
                yield return new object[] { new uint?[] { uint.MinValue, uint.MaxValue, null } };
            }
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "uint?[]")]
        [MemberData(nameof(NullableUInt32ArrayTestData))]
        public void NullableUInt32ArrayTest(uint?[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableUInt32Array, actual.Type);
            Assert.Equal(data, actual.NullableUInt32Array.RawValue.Select(_ => _.IsNull ? null : (uint?)_.RawValue));
            MakeSureNull(ORiN3ValueType.ORiN3NullableUInt32Array, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "uint?[]")]
        public void NullableUInt32ArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((uint?[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "ulont")]
        [InlineData(ulong.MinValue)]
        [InlineData(ulong.MaxValue)]
        public void UInt64Test(ulong data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3UInt64, actual.Type);
            Assert.Equal(data, actual.UInt64.RawValue);
            MakeSureNull(ORiN3ValueType.ORiN3UInt64, actual);
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "ulont[]")]
        [InlineData(new ulong[0])]
        [InlineData(new[] { ulong.MinValue })]
        [InlineData(new[] { ulong.MaxValue })]
        [InlineData(new[] { ulong.MinValue, ulong.MaxValue })]
        public void UInt164ArrayTest(ulong[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3UInt64Array, actual.Type);
            Assert.Equal(data, actual.UInt64Array.RawValue);
            MakeSureNull(ORiN3ValueType.ORiN3UInt64Array, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "ulont[]")]
        public void UInt64ArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((ulong[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "ulont?")]
        [InlineData(null)]
        [InlineData(ulong.MinValue)]
        [InlineData(ulong.MaxValue)]
        public void NullableUInt64Test(ulong? data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableUInt64, actual.Type);
            Assert.Equal(data.HasValue, !actual.NullableUInt64.IsNull);
            if (data.HasValue)
            {
                Assert.Equal(data.Value, actual.NullableUInt64.RawValue);
            }
            else
            {
                Assert.Equal(default, actual.NullableUInt64.RawValue);
            }
            MakeSureNull(ORiN3ValueType.ORiN3NullableUInt64, actual);
        }

        public static IEnumerable<object[]> NullableUInt64ArrayTestData
        {
            get
            {
                yield return new object[] { Array.Empty<ulong?>() };
                yield return new object[] { new ulong?[] { ulong.MinValue } };
                yield return new object[] { new ulong?[] { ulong.MaxValue } };
                yield return new object[] { new ulong?[] { null } };
                yield return new object[] { new ulong?[] { ulong.MinValue, ulong.MaxValue, null } };
            }
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "ulont?[]")]
        [MemberData(nameof(NullableUInt64ArrayTestData))]
        public void NullableUInt64ArrayTest(ulong?[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableUInt64Array, actual.Type);
            Assert.Equal(data, actual.NullableUInt64Array.RawValue.Select(_ => _.IsNull ? null : (ulong?)_.RawValue));
            MakeSureNull(ORiN3ValueType.ORiN3NullableUInt64Array, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "ulont?[]")]
        public void NullableUInt64ArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((ulong?[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "sbyte")]
        [InlineData(sbyte.MinValue)]
        [InlineData(sbyte.MaxValue)]
        [InlineData(0)]
        public void Int8Test(sbyte data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3Int8, actual.Type);
            Assert.Equal(data, actual.Int8.RawValue);
            MakeSureNull(ORiN3ValueType.ORiN3Int8, actual);
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "sbyte[]")]
        [InlineData(new sbyte[0])]
        [InlineData(new[] { sbyte.MinValue })]
        [InlineData(new[] { sbyte.MaxValue })]
        [InlineData(new[] { (sbyte)0 })]
        [InlineData(new[] { sbyte.MinValue, sbyte.MaxValue, (sbyte)0 })]
        public void Int8ArrayTest(sbyte[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3Int8Array, actual.Type);
            Assert.Equal(data, actual.Int8Array.RawValue.Select(_ => (sbyte)_));
            MakeSureNull(ORiN3ValueType.ORiN3Int8Array, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "sbyte[]")]
        public void Int8ArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((sbyte[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "sbyte?")]
        [InlineData(null)]
        [InlineData(sbyte.MinValue)]
        [InlineData(sbyte.MaxValue)]
        [InlineData((sbyte)0)]
        public void NullableInt8Test(sbyte? data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableInt8, actual.Type);
            Assert.Equal(data.HasValue, !actual.NullableInt8.IsNull);
            if (data.HasValue)
            {
                Assert.Equal(data.Value, actual.NullableInt8.RawValue);
            }
            else
            {
                Assert.Equal(default, actual.NullableInt8.RawValue);
            }
            MakeSureNull(ORiN3ValueType.ORiN3NullableInt8, actual);
        }

        public static IEnumerable<object[]> NullableInt8ArrayTestData
        {
            get
            {
                yield return new object[] { Array.Empty<sbyte?>() };
                yield return new object[] { new sbyte?[] { sbyte.MinValue } };
                yield return new object[] { new sbyte?[] { sbyte.MaxValue } };
                yield return new object[] { new sbyte?[] { null } };
                yield return new object[] { new sbyte?[] { sbyte.MinValue, sbyte.MaxValue, 0, null } };
            }
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "sbyte?[]")]
        [MemberData(nameof(NullableInt8ArrayTestData))]
        public void NullableInt8ArrayTest(sbyte?[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableInt8Array, actual.Type);
            Assert.Equal(data, actual.NullableInt8Array.RawValue.Select(_ => _.IsNull ? null : (sbyte?)_.RawValue));
            MakeSureNull(ORiN3ValueType.ORiN3NullableInt8Array, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "sbyte?[]")]
        public void NullableInt8ArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((sbyte?[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "short")]
        [InlineData(short.MinValue)]
        [InlineData(short.MaxValue)]
        [InlineData(0)]
        public void Int16Test(short data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3Int16, actual.Type);
            Assert.Equal(data, actual.Int16.RawValue);
            MakeSureNull(ORiN3ValueType.ORiN3Int16, actual);
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "short[]")]
        [InlineData(new short[0])]
        [InlineData(new[] { short.MinValue })]
        [InlineData(new[] { short.MaxValue })]
        [InlineData(new[] { (short)0 })]
        [InlineData(new[] { short.MinValue, short.MaxValue, (short)0 })]
        public void Int16ArrayTest(short[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3Int16Array, actual.Type);
            Assert.Equal(data, actual.Int16Array.RawValue.Select(_ => (short)_));
            MakeSureNull(ORiN3ValueType.ORiN3Int16Array, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "short[]")]
        public void Int16ArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((short[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "short?")]
        [InlineData(null)]
        [InlineData(short.MinValue)]
        [InlineData(short.MaxValue)]
        [InlineData((short)0)]
        public void NullableInt16Test(short? data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableInt16, actual.Type);
            Assert.Equal(data.HasValue, !actual.NullableInt16.IsNull);
            if (data.HasValue)
            {
                Assert.Equal(data.Value, actual.NullableInt16.RawValue);
            }
            else
            {
                Assert.Equal(default, actual.NullableInt16.RawValue);
            }
            MakeSureNull(ORiN3ValueType.ORiN3NullableInt16, actual);
        }

        public static IEnumerable<object[]> NullableInt16ArrayTestData
        {
            get
            {
                yield return new object[] { Array.Empty<short?>() };
                yield return new object[] { new short?[] { short.MinValue } };
                yield return new object[] { new short?[] { short.MaxValue } };
                yield return new object[] { new short?[] { null } };
                yield return new object[] { new short?[] { short.MinValue, short.MaxValue, 0, null } };
            }
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "short?[]")]
        [MemberData(nameof(NullableInt16ArrayTestData))]
        public void NullableInt16ArrayTest(short?[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableInt16Array, actual.Type);
            Assert.Equal(data, actual.NullableInt16Array.RawValue.Select(_ => _.IsNull ? null : (short?)_.RawValue));
            MakeSureNull(ORiN3ValueType.ORiN3NullableInt16Array, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "short?[]")]
        public void NullableInt16ArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((short?[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "int")]
        [InlineData(int.MinValue)]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        public void Int32Test(int data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3Int32, actual.Type);
            Assert.Equal(data, actual.Int32.RawValue);
            MakeSureNull(ORiN3ValueType.ORiN3Int32, actual);
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "int[]")]
        [InlineData(new int[0])]
        [InlineData(new[] { int.MinValue })]
        [InlineData(new[] { int.MaxValue })]
        [InlineData(new[] { 0 })]
        [InlineData(new[] { int.MinValue, int.MaxValue, 0 })]
        public void Int132ArrayTest(int[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3Int32Array, actual.Type);
            Assert.Equal(data, actual.Int32Array.RawValue);
            MakeSureNull(ORiN3ValueType.ORiN3Int32Array, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "int[]")]
        public void Int32ArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((int[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "int?")]
        [InlineData(null)]
        [InlineData(int.MinValue)]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        public void NullableInt32Test(int? data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableInt32, actual.Type);
            Assert.Equal(data.HasValue, !actual.NullableInt32.IsNull);
            if (data.HasValue)
            {
                Assert.Equal(data.Value, actual.NullableInt32.RawValue);
            }
            else
            {
                Assert.Equal(default, actual.NullableInt32.RawValue);
            }
            MakeSureNull(ORiN3ValueType.ORiN3NullableInt32, actual);
        }

        public static IEnumerable<object[]> NullableInt32ArrayTestData
        {
            get
            {
                yield return new object[] { Array.Empty<int?>() };
                yield return new object[] { new int?[] { int.MinValue } };
                yield return new object[] { new int?[] { int.MaxValue } };
                yield return new object[] { new int?[] { null } };
                yield return new object[] { new int?[] { int.MinValue, int.MaxValue, 0, null } };
            }
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "int?[]")]
        [MemberData(nameof(NullableInt32ArrayTestData))]
        public void NullableInt32ArrayTest(int?[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableInt32Array, actual.Type);
            Assert.Equal(data, actual.NullableInt32Array.RawValue.Select(_ => _.IsNull ? null : (int?)_.RawValue));
            MakeSureNull(ORiN3ValueType.ORiN3NullableInt32Array, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "int?[]")]
        public void NullableInt32ArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((int?[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "long")]
        [InlineData(long.MinValue)]
        [InlineData(long.MaxValue)]
        [InlineData(0L)]
        public void Int64Test(long data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3Int64, actual.Type);
            Assert.Equal(data, actual.Int64.RawValue);
            MakeSureNull(ORiN3ValueType.ORiN3Int64, actual);
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "long[]")]
        [InlineData(new long[0])]
        [InlineData(new[] { long.MinValue })]
        [InlineData(new[] { long.MaxValue })]
        [InlineData(new[] { 0L })]
        [InlineData(new[] { long.MinValue, long.MaxValue, 0L })]
        public void Int64ArrayTest(long[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3Int64Array, actual.Type);
            Assert.Equal(data, actual.Int64Array.RawValue);
            MakeSureNull(ORiN3ValueType.ORiN3Int64Array, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "long[]")]
        public void Int64ArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((long[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "long?")]
        [InlineData(null)]
        [InlineData(long.MinValue)]
        [InlineData(long.MaxValue)]
        [InlineData(0L)]
        public void NullableInt64Test(long? data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableInt64, actual.Type);
            Assert.Equal(data.HasValue, !actual.NullableInt64.IsNull);
            if (data.HasValue)
            {
                Assert.Equal(data.Value, actual.NullableInt64.RawValue);
            }
            else
            {
                Assert.Equal(default, actual.NullableInt64.RawValue);
            }
            MakeSureNull(ORiN3ValueType.ORiN3NullableInt64, actual);
        }

        public static IEnumerable<object[]> NullableInt64ArrayTestData
        {
            get
            {
                yield return new object[] { Array.Empty<long?>() };
                yield return new object[] { new long?[] { long.MinValue } };
                yield return new object[] { new long?[] { long.MaxValue } };
                yield return new object[] { new long?[] { null } };
                yield return new object[] { new long?[] { long.MinValue, long.MaxValue, 0, null } };
            }
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "long?[]")]
        [MemberData(nameof(NullableInt64ArrayTestData))]
        public void NullableInt64ArrayTest(long?[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableInt64Array, actual.Type);
            Assert.Equal(data, actual.NullableInt64Array.RawValue.Select(_ => _.IsNull ? null : (long?)_.RawValue));
            MakeSureNull(ORiN3ValueType.ORiN3NullableInt64Array, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "long?[]")]
        public void NullableInt64ArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((long?[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "float")]
        [InlineData(float.MinValue)]
        [InlineData(float.MaxValue)]
        [InlineData(float.NegativeInfinity)]
        [InlineData(float.PositiveInfinity)]
        [InlineData(float.NaN)]
        [InlineData(float.Epsilon)]
        [InlineData(0f)]
        public void FloatTest(float data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3Float, actual.Type);
            Assert.Equal(data, actual.Float.RawValue);
            MakeSureNull(ORiN3ValueType.ORiN3Float, actual);
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "float[]")]
        [InlineData(new float[0])]
        [InlineData(new[] { float.MinValue })]
        [InlineData(new[] { float.MaxValue })]
        [InlineData(new[] { float.NegativeInfinity })]
        [InlineData(new[] { float.PositiveInfinity })]
        [InlineData(new[] { float.NaN })]
        [InlineData(new[] { float.Epsilon })]
        [InlineData(new[] { 0f })]
        [InlineData(new[] { float.MinValue, float.MaxValue, float.PositiveInfinity, float.NegativeInfinity, float.NaN, float.Epsilon, 0f })]
        public void FloatArrayTest(float[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3FloatArray, actual.Type);
            Assert.Equal(data, actual.FloatArray.RawValue);
            MakeSureNull(ORiN3ValueType.ORiN3FloatArray, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "float[]")]
        public void FloatArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((float[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "float?")]
        [InlineData(null)]
        [InlineData(float.MinValue)]
        [InlineData(float.MaxValue)]
        [InlineData(float.NegativeInfinity)]
        [InlineData(float.PositiveInfinity)]
        [InlineData(float.NaN)]
        [InlineData(float.Epsilon)]
        [InlineData(0f)]
        public void NullableFloatTest(float? data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableFloat, actual.Type);
            Assert.Equal(data.HasValue, !actual.NullableFloat.IsNull);
            if (data.HasValue)
            {
                Assert.Equal(data.Value, actual.NullableFloat.RawValue);
            }
            else
            {
                Assert.Equal(default, actual.NullableFloat.RawValue);
            }
            MakeSureNull(ORiN3ValueType.ORiN3NullableFloat, actual);
        }

        public static IEnumerable<object[]> NullableFloatArrayTestData
        {
            get
            {
                yield return new object[] { Array.Empty<float?>() };
                yield return new object[] { new float?[] { float.MinValue } };
                yield return new object[] { new float?[] { float.MaxValue } };
                yield return new object[] { new float?[] { null } };
                yield return new object[] { new float?[] { float.MinValue, float.MaxValue, float.PositiveInfinity, float.NegativeInfinity, float.NaN, float.Epsilon, 0f, null } };
            }
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "float?[]")]
        [MemberData(nameof(NullableFloatArrayTestData))]
        public void NullableFloatArrayTest(float?[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableFloatArray, actual.Type);
            Assert.Equal(data, actual.NullableFloatArray.RawValue.Select(_ => _.IsNull ? null : (float?)_.RawValue));
            MakeSureNull(ORiN3ValueType.ORiN3NullableFloatArray, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "float?[]")]
        public void NullableFloatArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((float?[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "double")]
        [InlineData(double.MinValue)]
        [InlineData(double.MaxValue)]
        [InlineData(double.NegativeInfinity)]
        [InlineData(double.PositiveInfinity)]
        [InlineData(double.NaN)]
        [InlineData(double.Epsilon)]
        [InlineData(0f)]
        public void DoubleTest(double data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3Double, actual.Type);
            Assert.Equal(data, actual.Double.RawValue);
            MakeSureNull(ORiN3ValueType.ORiN3Double, actual);
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "double[]")]
        [InlineData(new double[0])]
        [InlineData(new[] { double.MinValue })]
        [InlineData(new[] { double.MaxValue })]
        [InlineData(new[] { double.NegativeInfinity })]
        [InlineData(new[] { double.PositiveInfinity })]
        [InlineData(new[] { double.NaN })]
        [InlineData(new[] { double.Epsilon })]
        [InlineData(new[] { 0.0 })]
        [InlineData(new[] { double.MinValue, double.MaxValue, double.PositiveInfinity, double.NegativeInfinity, double.NaN, double.Epsilon, 0.0 })]
        public void DoubleArrayTest(double[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3DoubleArray, actual.Type);
            Assert.Equal(data, actual.DoubleArray.RawValue);
            MakeSureNull(ORiN3ValueType.ORiN3DoubleArray, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "double[]")]
        public void DoubleArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((double[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "double?")]
        [InlineData(null)]
        [InlineData(double.MinValue)]
        [InlineData(double.MaxValue)]
        [InlineData(double.NegativeInfinity)]
        [InlineData(double.PositiveInfinity)]
        [InlineData(double.NaN)]
        [InlineData(double.Epsilon)]
        [InlineData(0.0)]
        public void NullableDoubleTest(double? data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableDouble, actual.Type);
            Assert.Equal(data.HasValue, !actual.NullableDouble.IsNull);
            if (data.HasValue)
            {
                Assert.Equal(data.Value, actual.NullableDouble.RawValue);
            }
            else
            {
                Assert.Equal(default, actual.NullableDouble.RawValue);
            }
            MakeSureNull(ORiN3ValueType.ORiN3NullableDouble, actual);
        }

        public static IEnumerable<object[]> NullableDoubleArrayTestData
        {
            get
            {
                yield return new object[] { Array.Empty<double?>() };
                yield return new object[] { new double?[] { double.MinValue } };
                yield return new object[] { new double?[] { double.MaxValue } };
                yield return new object[] { new double?[] { null } };
                yield return new object[] { new double?[] { double.MinValue, double.MaxValue, double.PositiveInfinity, double.NegativeInfinity, double.NaN, double.Epsilon, 0f, null } };
            }
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "double?[]")]
        [MemberData(nameof(NullableDoubleArrayTestData))]
        public void NullableDoubleArrayTest(double?[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableDoubleArray, actual.Type);
            Assert.Equal(data, actual.NullableDoubleArray.RawValue.Select(_ => _.IsNull ? null : (double?)_.RawValue));
            MakeSureNull(ORiN3ValueType.ORiN3NullableDoubleArray, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "double?[]")]
        public void NullableDoubleArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((double?[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "DateTime")]
        [InlineData(0)]
        [InlineData(3155378975999999999)]
        public void DateTimeTest(long ticks)
        {
            var data = DateTime.FromBinary(ticks);
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3DateTime, actual.Type);
            Assert.Equal(ticks, actual.DateTime.RawValue);
            MakeSureNull(ORiN3ValueType.ORiN3DateTime, actual);
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "DateTime[]")]
        [InlineData(new long[0])]
        [InlineData(new long[] { 0 })]
        [InlineData(new long[] { 3155378975999999999 })]
        [InlineData(new long[] { 0, 3155378975999999999, 0 })]
        public void DateTimeArrayTest(long[] ticks)
        {
            var data = ticks.Select(_ => DateTime.FromBinary(_)).ToArray();
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3DateTimeArray, actual.Type);
            Assert.Equal(data, actual.DateTimeArray.RawValue.Select(_ => DateTime.FromBinary(_)));
            MakeSureNull(ORiN3ValueType.ORiN3DateTimeArray, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "DateTime[]")]
        public void DateTimeArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((DateTime[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "DateTime?")]
        [InlineData(null)]
        [InlineData(0L)]
        [InlineData(3155378975999999999)]
        public void NullableDateTimeTest(long? ticks)
        {
            DateTime? data = ticks.HasValue ? DateTime.FromBinary(ticks.Value) : null;
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableDateTime, actual.Type);
            Assert.Equal(data.HasValue, !actual.NullableDateTime.IsNull);
            if (data.HasValue)
            {
                Assert.Equal(data.Value.Ticks, actual.NullableDateTime.RawValue);
            }
            else
            {
                Assert.Equal(default, actual.NullableDateTime.RawValue);
            }
            MakeSureNull(ORiN3ValueType.ORiN3NullableDateTime, actual);
        }

        public static IEnumerable<object[]> NullableDateTimeArrayTestData
        {
            get
            {
                yield return new object[] { Array.Empty<DateTime?>() };
                yield return new object[] { new DateTime?[] { DateTime.MinValue } };
                yield return new object[] { new DateTime?[] { DateTime.MaxValue } };
                yield return new object[] { new DateTime?[] { null } };
                yield return new object[] { new DateTime?[] { DateTime.MinValue, DateTime.MaxValue, null } };
            }
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "DateTime?[]")]
        [MemberData(nameof(NullableDateTimeArrayTestData))]
        public void NullableDateTimeArrayTest(DateTime?[] data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3NullableDateTimeArray, actual.Type);
            Assert.Equal(data, actual.NullableDateTimeArray.RawValue.Select(_ => _.IsNull ? null : (DateTime?)DateTime.FromBinary(_.RawValue)));
            MakeSureNull(ORiN3ValueType.ORiN3NullableDateTimeArray, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "DateTime?[]")]
        public void NullableDateTimeArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((DateTime?[])null);
            });
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "string")]
        [InlineData("")]
        [InlineData("test")]
        public void StringTest(string data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3String, actual.Type);
            Assert.Equal(data, actual.String.RawValue);
            MakeSureNull(ORiN3ValueType.ORiN3String, actual);
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "string[]")]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(3)]
        public void StringArrayTest(int count)
        {
            var data = new string[count];
            for (var i = 0; i < count; ++i)
            {
                data[i] = count.ToString();
            }
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3StringArray, actual.Type);
            Assert.Equal(data, actual.StringArray.RawValue.Select(_ => _.IsNull ? null : _.RawValue));
            MakeSureNull(ORiN3ValueType.ORiN3StringArray, actual);
        }

        public static IEnumerable<object[]> ObjectTestData
        {
            get
            {
                yield return new object[] { null };
                yield return new object[] { true };
                yield return new object[] { false };
                yield return new object[] { byte.MinValue };
                yield return new object[] { byte.MaxValue };
                yield return new object[] { ushort.MinValue };
                yield return new object[] { ushort.MaxValue };
                yield return new object[] { uint.MinValue };
                yield return new object[] { uint.MaxValue };
                yield return new object[] { ulong.MinValue };
                yield return new object[] { ulong.MaxValue };
                yield return new object[] { sbyte.MinValue };
                yield return new object[] { sbyte.MaxValue };
                yield return new object[] { short.MinValue };
                yield return new object[] { short.MaxValue };
                yield return new object[] { int.MinValue };
                yield return new object[] { int.MaxValue };
                yield return new object[] { long.MinValue };
                yield return new object[] { long.MaxValue };
                yield return new object[] { DateTime.MinValue };
                yield return new object[] { DateTime.MaxValue };
                yield return new object[] { float.MinValue };
                yield return new object[] { float.MaxValue };
                yield return new object[] { float.PositiveInfinity };
                yield return new object[] { float.NegativeInfinity };
                yield return new object[] { float.NaN };
                yield return new object[] { double.MinValue };
                yield return new object[] { double.MaxValue };
                yield return new object[] { double.PositiveInfinity };
                yield return new object[] { double.NegativeInfinity };
                yield return new object[] { double.NaN };
                yield return new object[] { string.Empty };
                yield return new object[] { "aaa" };
                yield return new object[] { DateTime.MaxValue };
                yield return new object[] { Array.Empty<object>() };
                yield return new object[] { new object[] { true, new bool[] { false, true } } };
                yield return new object[] { new object[] { new bool[] { false, true }, new bool?[] { true, null, false } } };
                yield return new object[] { new object[] { new bool?[] { true, null, false }, (byte)123 } };
                yield return new object[] { new object[] { (byte)123, new byte[] { byte.MinValue, byte.MaxValue, 123 } } };
                yield return new object[] { new object[] { new byte[] { byte.MinValue, byte.MaxValue, 123 }, new byte?[] { byte.MinValue, byte.MaxValue, null, 123 } } };
                yield return new object[] { new object[] { new byte?[] { byte.MinValue, byte.MaxValue, null, 123 }, (sbyte)12 } };
                yield return new object[] { new object[] { (sbyte)12, new sbyte[] { sbyte.MinValue, sbyte.MaxValue, 123 } } };
                yield return new object[] { new object[] { new sbyte[] { sbyte.MinValue, sbyte.MaxValue, 123 }, new sbyte?[] { sbyte.MinValue, sbyte.MaxValue, null, 123 } } };
                yield return new object[] { new object[] { new sbyte?[] { sbyte.MinValue, sbyte.MaxValue, null, 123 }, (ushort)12345 } };
                yield return new object[] { new object[] { (ushort)12345, new ushort[] { ushort.MinValue, ushort.MaxValue, 123 } } };
                yield return new object[] { new object[] { new ushort[] { ushort.MinValue, ushort.MaxValue, 123 }, new ushort?[] { ushort.MinValue, ushort.MaxValue, null, 123 } } };
                yield return new object[] { new object[] { new ushort?[] { ushort.MinValue, ushort.MaxValue, null, 123 }, (short)111 } };
                yield return new object[] { new object[] { (short)111, new short[] { short.MinValue, short.MaxValue, 123 } } };
                yield return new object[] { new object[] { new short[] { short.MinValue, short.MaxValue, 123 }, new short?[] { short.MinValue, short.MaxValue, null, 123 } } };
                yield return new object[] { new object[] { new short?[] { short.MinValue, short.MaxValue, null, 123 }, (uint)123456 } };
                yield return new object[] { new object[] { (uint)123456, new uint[] { uint.MinValue, uint.MaxValue, 123 } } };
                yield return new object[] { new object[] { new uint[] { uint.MinValue, uint.MaxValue, 123 }, new uint?[] { uint.MinValue, uint.MaxValue, null, 123 } } };
                yield return new object[] { new object[] { new uint?[] { uint.MinValue, uint.MaxValue, null, 123 }, 654321 } };
                yield return new object[] { new object[] { 654321, new int[] { int.MinValue, int.MaxValue, 123 }, } };
                yield return new object[] { new object[] { new int[] { int.MinValue, int.MaxValue, 123 }, new int?[] { int.MinValue, int.MaxValue, null, 123 } } };
                yield return new object[] { new object[] { new int?[] { int.MinValue, int.MaxValue, null, 123 }, (ulong)5555455 } };
                yield return new object[] { new object[] { (ulong)5555455, new ulong[] { ulong.MinValue, ulong.MaxValue, 123 } } };
                yield return new object[] { new object[] { new ulong[] { ulong.MinValue, ulong.MaxValue, 123 }, new ulong?[] { ulong.MinValue, ulong.MaxValue, null, 123 } } };
                yield return new object[] { new object[] { new ulong?[] { ulong.MinValue, ulong.MaxValue, null, 123 }, (long)3333321 } };
                yield return new object[] { new object[] { (long)3333321, new long[] { long.MinValue, long.MaxValue, 123 } } };
                yield return new object[] { new object[] { new long[] { long.MinValue, long.MaxValue, 123 }, new long?[] { long.MinValue, long.MaxValue, null, 123 } } };
                yield return new object[] { new object[] { new long?[] { long.MinValue, long.MaxValue, null, 123 }, 0.1F } };
                yield return new object[] { new object[] { 0.1F, new float[] { float.MinValue, float.MaxValue, float.PositiveInfinity, float.NegativeInfinity, float.NaN, 123F }, } };
                yield return new object[] { new object[] { new float[] { float.MinValue, float.MaxValue, float.PositiveInfinity, float.NegativeInfinity, float.NaN, 123F }, new float?[] { float.MinValue, float.MaxValue, float.PositiveInfinity, float.NegativeInfinity, float.NaN, null, 123F }, } };
                yield return new object[] { new object[] { new float?[] { float.MinValue, float.MaxValue, float.PositiveInfinity, float.NegativeInfinity, float.NaN, null, 123F }, 1.1D } };
                yield return new object[] { new object[] { 1.1D, new double[] { double.MinValue, double.MaxValue, double.PositiveInfinity, double.NegativeInfinity, double.NaN, 123F } } };
                yield return new object[] { new object[] { new double[] { double.MinValue, double.MaxValue, double.PositiveInfinity, double.NegativeInfinity, double.NaN, 123F }, new double?[] { double.MinValue, double.MaxValue, double.PositiveInfinity, double.NegativeInfinity, double.NaN, null, 123F } } };
                yield return new object[] { new object[] { new double?[] { double.MinValue, double.MaxValue, double.PositiveInfinity, double.NegativeInfinity, double.NaN, null, 123F }, DateTime.Now } };
                yield return new object[] { new object[] { DateTime.Now, new DateTime[] { DateTime.MinValue, DateTime.MinValue } } };
                yield return new object[] { new object[] { new DateTime[] { DateTime.MinValue, DateTime.MinValue }, new DateTime?[] { DateTime.MinValue, null, DateTime.MinValue } } };
                yield return new object[] { new object[] { new DateTime?[] { DateTime.MinValue, null, DateTime.MinValue }, "aaaaabbbbbcccc" } };
                yield return new object[] { new object[] { "aaaaabbbbbcccc", new string[] { "12345", string.Empty, null, "AAAABBBBCCC" } } };
                yield return new object[] { new object[] { new string[] { "12345", string.Empty, null, "AAAABBBBCCC" }, true } };
            }
        }

        [Theory]
        [Trait(nameof(ORiN3ValueFactory), "object")]
        [MemberData(nameof(ObjectTestData))]
        public void ObjectTest(object data)
        {
            var actual = ORiN3ValueFactory.Create(data);
            Assert.Equal((int)ORiN3ValueType.ORiN3Object, actual.Type);
            Assert.Equal(data, ORiN3BinaryConverter.ToObject(actual.Object.RawValue.Span));
            MakeSureNull(ORiN3ValueType.ORiN3Object, actual);
        }

        [Fact]
        [Trait(nameof(ORiN3ValueFactory), "string[]")]
        public void StringArrayWithNullTest()
        {
            Assert.Throws<ArgumentNullException>(() =>
            {
                var actual = ORiN3ValueFactory.Create((string[])null);
            });
        }
    }
}
